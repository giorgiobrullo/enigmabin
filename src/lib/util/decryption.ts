import { MlKem1024 } from 'mlkem';
import _sodium from 'libsodium-wrappers';
import type { EncryptedData, PasteContent } from './encryption';

export async function decrypt(
    encrypted: EncryptedData,
    decryptionKeyBase64: string
): Promise<PasteContent> {
    await _sodium.ready;
    const sodium = _sodium;

    try {
        // Decode the base64 decryption key back into bytes
        const combinedKey = sodium.from_base64(decryptionKeyBase64);
        
        // Detect if this was encrypted with quantum resistance by checking for quantum-specific fields
        const isQuantumMode = encrypted.ciphertext1 !== undefined && encrypted.nonce1 !== undefined;
        const isV2 = encrypted.version === '2';

        // Select the appropriate decrypt function based on version
        const aeadDecrypt = isV2
            ? sodium.crypto_aead_xchacha20poly1305_ietf_decrypt
            : sodium.crypto_aead_chacha20poly1305_ietf_decrypt;

        if (isQuantumMode) {
            // In quantum mode, the decryption key contains:
            // 1. MLKEM secret key (3168 bytes) - for quantum-resistant layer
            // 2. X25519 secret key (32 bytes) - for classical layer
            // 3. X25519 public key (32 bytes) - needed for unsealing
            const secretKey1 = combinedKey.slice(0, 3168);
            const secretKey2 = combinedKey.slice(3168, 3168 + 32);
            const publicKey2 = combinedKey.slice(3168 + 32);

            // Layer 1: Quantum (Kyber) decryption
            // - Uses MLKEM to recover the shared secret that was used during encryption
            // - This shared secret was generated by the encryptor and will be identical to what they generated
            const kyber = new MlKem1024();
            const sharedSecret1 = await kyber.decap(
                sodium.from_base64(encrypted.ciphertext1!), 
                secretKey1
            );

            // Layer 2: Classical (X25519) decryption
            // - First, unseal the second shared secret using X25519 keys
            // - crypto_box_seal_open uses the keypair to decrypt the sealed box containing the shared secret
            const sharedSecret2 = sodium.crypto_box_seal_open(
                sodium.from_base64(encrypted.ciphertext2),
                publicKey2,
                secretKey2
            ) as Uint8Array;

            // Decrypt outer layer using the X25519 shared secret
            const decrypted1 = aeadDecrypt(
                null,
                sodium.from_base64(encrypted.content),
                null,
                sodium.from_base64(encrypted.nonce2),
                sharedSecret2
            ) as Uint8Array;

            // Decrypt inner layer using the Kyber shared secret
            const decrypted2 = aeadDecrypt(
                null,
                decrypted1,
                null,
                sodium.from_base64(encrypted.nonce1!),
                sharedSecret1
            ) as Uint8Array;

            return JSON.parse(sodium.to_string(decrypted2));

        } else {
            // In classical mode, the decryption key contains:
            // 1. X25519 secret key (32 bytes) - for decryption
            // 2. X25519 public key (32 bytes) - needed for unsealing
            const secretKey = combinedKey.slice(0, 32);
            const publicKey = combinedKey.slice(32);

            // Decrypt the shared secret from the sealed box
            // - During encryption, a random shared secret was generated and sealed with the public key
            // - Only the holder of the private key can unseal and recover this shared secret
            // - This provides the security of asymmetric encryption while allowing use of faster symmetric encryption
            const sharedSecret = sodium.crypto_box_seal_open(
                sodium.from_base64(encrypted.ciphertext2),
                publicKey,
                secretKey
            ) as Uint8Array;

            // Decrypt the actual content using the shared secret
            const decrypted = aeadDecrypt(
                null,
                sodium.from_base64(encrypted.content),
                null,
                sodium.from_base64(encrypted.nonce2),
                sharedSecret
            ) as Uint8Array;

            // Convert the decrypted bytes back into the original JSON object
            return JSON.parse(sodium.to_string(decrypted));
        }

    } catch (error) {
        console.error('Decryption failed:', error);
        throw new Error('Failed to decrypt content');
    }
}